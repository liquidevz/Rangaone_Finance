name: Zero Downtime Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          timeout: 1200s
          script: |
            set -euo pipefail

            APP_PATH="/home/rangaone/htdocs/www.rangaone.finance/Rangaone_Finance"
            IMAGE_PREFIX="rangaone-fe"
            CONTAINER_OLD="Rangaone_Finance"
            CONTAINER_NEW="Rangaone_Finance_new"
            NEW_PORT=3003
            PROD_PORT=3000

            echo "ðŸš€ Starting zero downtime deployment..."

            cd $APP_PATH

            echo "ðŸ“¥ Pulling latest code..."
            git stash || true
            git pull origin main --force

            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            NEW_IMAGE="${IMAGE_PREFIX}:${TIMESTAMP}"
            echo "ðŸ³ Building new Docker image: $NEW_IMAGE"

            # Use build cache from latest image if exists
            docker build --pull --progress=plain -t $NEW_IMAGE .

            echo "ðŸ§ª Starting new container on port $NEW_PORT..."
            docker run -d \
              --name $CONTAINER_NEW \
              -p ${NEW_PORT}:3000 \
              --restart unless-stopped \
              -e NODE_ENV=production \
              -e NEXT_TELEMETRY_DISABLED=1 \
              -e VERCEL=1 \
              -e CI=true \
              $NEW_IMAGE

            echo "ðŸ©º Waiting for new container to become healthy..."
            max_attempts=30
            count=0
            until curl -fs http://localhost:${NEW_PORT}/ >/dev/null 2>&1 || [ $count -eq $max_attempts ]; do
              echo "â³ Waiting for new container... ($count/$max_attempts)"
              count=$((count + 1))
              sleep 2
            done

            if [ $count -eq $max_attempts ]; then
              echo "âŒ New container failed health check, rolling back..."
              docker logs $CONTAINER_NEW || true
              docker stop $CONTAINER_NEW || true
              docker rm $CONTAINER_NEW || true
              docker rmi $NEW_IMAGE || true
              exit 1
            fi

            echo "âœ… New container is healthy! Proceeding with switch..."

            echo "ðŸ›‘ Stopping any containers on port $PROD_PORT..."
            docker ps --format "table {{.Names}}\t{{.Ports}}" | grep "${PROD_PORT}" | awk '{print $1}' | xargs -r docker stop || true
            docker ps -a --format "table {{.Names}}\t{{.Ports}}" | grep "${PROD_PORT}" | awk '{print $1}' | xargs -r docker rm || true

            docker stop $CONTAINER_OLD 2>/dev/null || true
            docker rm $CONTAINER_OLD 2>/dev/null || true

            echo "âŒ› Waiting for port $PROD_PORT to be released..."
            sleep 3
            if netstat -tulpn | grep :${PROD_PORT} > /dev/null 2>&1; then
              echo "âš ï¸ Port still busy, waiting longer..."
              sleep 5
            fi

            echo "ðŸš€ Promoting new container to production..."
            docker run -d \
              --name $CONTAINER_OLD \
              -p ${PROD_PORT}:3000 \
              --restart unless-stopped \
              -e NODE_ENV=production \
              -e NEXT_TELEMETRY_DISABLED=1 \
              -e VERCEL=1 \
              -e CI=true \
              $NEW_IMAGE

            echo "ðŸ§ª Final health check..."
            sleep 5
            if ! docker ps | grep -q "$CONTAINER_OLD"; then
              echo "âŒ Final deployment failed, rolling back..."
              docker logs $CONTAINER_OLD
              exit 1
            fi

            echo "ðŸ§¹ Cleaning up old containers and images..."
            docker stop $CONTAINER_NEW 2>/dev/null || true
            docker rm $CONTAINER_NEW 2>/dev/null || true

            # Keep last 2 builds
            OLD_IMAGES=$(docker images $IMAGE_PREFIX --format "{{.Tag}}" | grep -E "^[0-9]{8}-[0-9]{6}$" | sort -r | tail -n +3)
            for tag in $OLD_IMAGES; do
              docker rmi "${IMAGE_PREFIX}:${tag}" 2>/dev/null || true
            done
            docker image prune -f

            echo "ðŸ“Š Current running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep $CONTAINER_OLD

            echo "ðŸŽ‰ Zero downtime deployment completed successfully!"
