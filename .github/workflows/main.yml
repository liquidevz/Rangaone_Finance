name: üöÄ Zero Downtime Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: üß© Deploy to Production Server
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # 1Ô∏è‚É£ Checkout the latest repository code
      - name: üì¶ Checkout Repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ SSH into server and perform zero-downtime Docker deployment
      - name: üöÄ Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          timeout: 36000s
          script: |
            set -euo pipefail
            IFS=$'\n\t'

            ########################################
            # üîß Configuration
            ########################################
            APP_PATH="/home/rangaone/htdocs/www.rangaone.finance/Rangaone_Finance"
            IMAGE_PREFIX="rangaone-fe"
            CONTAINER_PROD="rangaone_fe_prod"
            CONTAINER_TMP="rangaone_fe_tmp"
            NEW_PORT=3003
            PROD_PORT=3000
            HEALTH_PATH="/api/health"
            HEALTH_TIMEOUT=60
            HEALTH_INTERVAL=2
            KEEP_BUILDS=2
            ENV_FILE=".env"
            KEEP_ENV_BACKUPS=3

            echo "üöÄ Starting Zero-Downtime Deployment for ${IMAGE_PREFIX}..."

            ########################################
            # üìÇ Step 1: Prepare Application Directory
            ########################################
            cd "$APP_PATH"

            ########################################
            # üîÑ Step 2: Backup and Pull Latest Code
            ########################################
            echo "üì• Pulling latest code from main..."
            BACKUP_ENV=""

            if [ -f "${ENV_FILE}" ]; then
              BACKUP_ENV="${ENV_FILE}.bak_$(date +%Y%m%d-%H%M%S)"
              echo "üßæ Backing up .env to ${BACKUP_ENV}"
              cp "${ENV_FILE}" "${BACKUP_ENV}"
            else
              echo "‚ö†Ô∏è No .env found, skipping backup."
            fi

            git update-index --assume-unchanged "${ENV_FILE}" 2>/dev/null || true
            git stash --all || true
            git fetch origin main --quiet
            git reset --hard origin/main

            if [ -n "${BACKUP_ENV}" ] && [ -f "${BACKUP_ENV}" ]; then
              echo "‚ôªÔ∏è Restoring .env from backup..."
              cp -f "${BACKUP_ENV}" "${ENV_FILE}"
            fi

            echo "üßπ Cleaning up old .env backups..."
            mapfile -t ENV_BACKUPS < <(ls -1t "${ENV_FILE}".bak_* 2>/dev/null || true)
            if [ "${#ENV_BACKUPS[@]}" -gt "${KEEP_ENV_BACKUPS}" ]; then
              for old in "${ENV_BACKUPS[@]:${KEEP_ENV_BACKUPS}}"; do
                echo "üóëÔ∏è Removing old backup: ${old}"
                rm -f "${old}" || true
              done
            fi

            ########################################
            # üê≥ Step 3: Build New Docker Image
            ########################################
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            NEW_IMAGE="${IMAGE_PREFIX}:${TIMESTAMP}"

            echo "üî® Building new Docker image: ${NEW_IMAGE}"
            docker rm -f "${CONTAINER_TMP}" 2>/dev/null || true
            docker build --pull --progress=plain -t "${NEW_IMAGE}" .

            ########################################
            # üß™ Step 4: Start Temporary Container
            ########################################
            echo "üß™ Starting temporary container ${CONTAINER_TMP} on port ${NEW_PORT}..."
            RUN_CMD=(docker run -d --name "${CONTAINER_TMP}" --restart unless-stopped \
              -p "${NEW_PORT}:3000" \
              -e NODE_ENV=production \
              -e NEXT_TELEMETRY_DISABLED=1 \
              -e VERCEL=1 \
              -e CI=true)

            if [ -f "${ENV_FILE}" ]; then
              RUN_CMD+=(--env-file "${ENV_FILE}")
            fi

            RUN_CMD+=("${NEW_IMAGE}")
            "${RUN_CMD[@]}"

            echo "‚è≥ Waiting for health check on http://localhost:${NEW_PORT}${HEALTH_PATH}"
            elapsed=0
            until curl -fsS "http://localhost:${NEW_PORT}${HEALTH_PATH}" >/dev/null 2>&1; do
              if [ "$elapsed" -ge "$HEALTH_TIMEOUT" ]; then
                echo "‚ùå Health check failed after ${HEALTH_TIMEOUT}s. Rolling back..."
                docker logs "${CONTAINER_TMP}" || true
                docker rm -f "${CONTAINER_TMP}" || true
                docker rmi "${NEW_IMAGE}" || true
                exit 1
              fi
              printf "."
              sleep "${HEALTH_INTERVAL}"
              elapsed=$((elapsed + HEALTH_INTERVAL))
            done
            echo ""
            echo "‚úÖ Temporary container healthy!"

            ########################################
            # üîÅ Step 5: Swap Containers
            ########################################
            echo "üõë Stopping current production container..."
            if docker ps -a --format '{{.Names}}' | grep -xq "${CONTAINER_PROD}"; then
              docker stop "${CONTAINER_PROD}" || true
              docker rm "${CONTAINER_PROD}" || true
            else
              echo "‚öôÔ∏è No named prod container found; checking port ${PROD_PORT}..."
              docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":${PROD_PORT}" | awk '{print $1}' | xargs -r docker stop || true
              docker ps -a --format "{{.Names}}\t{{.Ports}}" | grep ":${PROD_PORT}" | awk '{print $1}' | xargs -r docker rm || true
            fi

            echo "‚åõ Waiting for port ${PROD_PORT} to be released..."
            sleep 2
            if ss -ltn "( sport = :${PROD_PORT} )" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Port ${PROD_PORT} still in use, waiting 3s more..."
              sleep 3
            fi

            echo "üöÄ Starting production container ${CONTAINER_PROD}..."
            PROD_RUN_CMD=(docker run -d --name "${CONTAINER_PROD}" --restart unless-stopped \
              -p "${PROD_PORT}:3000" \
              -e NODE_ENV=production \
              -e NEXT_TELEMETRY_DISABLED=1 \
              -e VERCEL=1 \
              -e CI=true)
            if [ -f "${ENV_FILE}" ]; then
              PROD_RUN_CMD+=(--env-file "${ENV_FILE}")
            fi
            PROD_RUN_CMD+=("${NEW_IMAGE}")
            "${PROD_RUN_CMD[@]}"

            ########################################
            # ü©∫ Step 6: Verify Production Health
            ########################################
            echo "ü©∫ Checking production health..."
            sleep 3
            if ! curl -fsS "http://localhost:${PROD_PORT}${HEALTH_PATH}" >/dev/null 2>&1; then
              echo "‚ùå Production health check failed. Rolling back..."
              docker logs "${CONTAINER_PROD}" || true
              docker rm -f "${CONTAINER_PROD}" || true

              PREV_IMAGE=$(docker images "${IMAGE_PREFIX}" --format '{{.Repository}}:{{.Tag}}' \
                | grep -E "${IMAGE_PREFIX}:[0-9]{8}-[0-9]{6}" \
                | grep -v "${TIMESTAMP}" | head -n1 || true)

              if [ -n "${PREV_IMAGE}" ]; then
                echo "üîÅ Rolling back to previous image: ${PREV_IMAGE}"
                docker run -d --name "${CONTAINER_PROD}" --restart unless-stopped \
                  -p "${PROD_PORT}:3000" \
                  -e NODE_ENV=production \
                  -e NEXT_TELEMETRY_DISABLED=1 \
                  "${PREV_IMAGE}" || true
                sleep 3
              fi

              docker rm -f "${CONTAINER_TMP}" || true
              docker rmi "${NEW_IMAGE}" || true
              exit 1
            fi

            echo "‚úÖ Production container is healthy!"

            ########################################
            # üßπ Step 7: Cleanup Old Images & Containers
            ########################################
            docker rm -f "${CONTAINER_TMP}" 2>/dev/null || true
            echo "üßπ Cleaning up old images (keeping last ${KEEP_BUILDS})..."
            mapfile -t TAGS < <(docker images "${IMAGE_PREFIX}" --format '{{.Tag}}' | grep -E "^[0-9]{8}-[0-9]{6}$" | sort -r)
            if [ "${#TAGS[@]}" -gt "${KEEP_BUILDS}" ]; then
              for t in "${TAGS[@]:${KEEP_BUILDS}}"; do
                echo "üóëÔ∏è Removing image ${IMAGE_PREFIX}:${t}"
                docker rmi "${IMAGE_PREFIX}:${t}" || true
              done
            fi
            docker image prune -f || true

            ########################################
            # üìã Summary
            ########################################
            echo "üì¶ Current Running Containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo "üéâ Deployment Complete: ${NEW_IMAGE} ‚Üí ${CONTAINER_PROD}"